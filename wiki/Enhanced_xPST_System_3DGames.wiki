#summary One-sentence summary of this page.

= Extensions to xPST system to enable authoring tutors in 3D games =

xPST systems has been extended to enable authoring of tutors in 3D games. Authoring in 3D games differs substantially from authoring tutors for traditional GUI software in terms of the inherent domain complexity involved, different types of feedback required and interactions generated by various entities apart from the student.

== Enhanced xPST Architecture ==s
http://xpst.googlecode.com/svn/trunk/design/enhanced_architecture.png

== 3D Games Vs Traditional GUI Software or Websites ==

In a traditional GUI application or website, there are usually a set of controls (e.g. buttons, menus) that correspond one-to-one with a set of features. Some of these controls typically remain on screen while the user works. The two-part architecture typically consists of an application (e.g. Microsoft Word or Adobe Photoshop, or Amazon.com or Google.com) that has particular state while user-created content (e.g. a document, an image, or a query) is shaped by the user. A user's actions will typically evoke similar responses if done repetitively. In a game, on the other hand, a user's actions are frequently dependent on the context of other entities and the timecourse within the game. Rather than the user changing a file or query within an application that maintains a state, the gamer is focused on changing the application's state within the game state space. The states can be discretely defined, and they then act as the goalnodes: the user's goal is not to complete a textbox with a certain correct answer but rather to reach a specific state. The granularity at which these states needs to be defined depends on the author and the complexity of the task. The traditional GUI software and websites are typically a static system where all the events are triggered by the student (player). But 3D games are more like a dynamic system where interactions can happen between various entities in the game apart from the player and the events can be triggered by different entities in the game (e.g. by automated enemy players, or "constructive forces" in military terminology). The events generated are split into two categories: the events generated by the player and the events generated by other entities.

Unlike the traditional GUI software or websites, 3D games require the student to navigate through a simulated environment, the map, and sometimes communicate with the other entities in the game. This calls for the authoring system to provide tools to support tutoring on communication-based and location-based subtasks, e.g., "Identify yourself to the guard" or "Return to mission headquarters to give a report."

== Extensions to xPST ==

In order to accommodate the differences between 3D games and traditional GUI software or websites, we have added the following extensions to the xPST architecture to facilitate easy authoring of ITSs in 3D games.

=== Actions by Non-Player Objects ===

Events can be triggered by non-player objects in 3D games. These events are modeled as hypothetical events by a Player-class object which is not the user.

For example _italicAvatar1:request-answer_ is the goalnode corresponding to requesting an answer from the Avatar1 entity, where _italicAvatar1_ is the unique id of the entity and _italicrequest-answer_ is the associated action. This approach is useful in tutoring on generic actions associated with any entity in the game, such as Tanker1:explode, Enemy1:attack. This is a more generic way of handling events compared to the previous xPST architecture in which the unique ID attribute always corresponds to the Player class object and was hence ignored while writing in the file. This is because the previous xPST architecture could support tutoring only on events generated by the Player.

=== Communication Events ===

Unlike the traditional GUI software or websites, many of the tasks in 3D games require the student to be able to communicate with other player entities in the game. We have extended xPST to support tutoring on communication events by using a special goalnode _italicstarttalk_, to initiate the communication with other entities. The student will be able to choose the entity with which to communicate and the message to communicate. This approach facilitates tutoring on the protocol of communication and the message that is being communicated, a common training task in the military, where communication is frequently highly-structured.

http://xpst.googlecode.com/svn/trunk/design/commevents.jpeg

_*Figure 1:*shows the instantiation of _italicstarttalk_ goalnode along with the UI for the user to communicate with the other players._